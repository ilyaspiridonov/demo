---
layout: post
title: Самая большая содержательная краска (LCP)
authors:
  - philipwalton
date: '2019-08-08'
updated: '2020-06-17'
description: |2

  В этом посте представлена метрика Крупнейшего содержательного рисования (LCP) и объясняется

  как это измерить
tags:
  - performance
  - metrics
---

{% Aside %} Крупнейшая отрисовка содержимого (LCP) - важный, ориентированный на пользователя показатель для измерения [воспринимаемой скорости загрузки,](/user-centric-performance-metrics/#types-of-metrics) поскольку он отмечает момент на шкале времени загрузки страницы, когда, вероятно, загрузился основной контент страницы - быстрая LCP помогает убедить пользователя в том, что страница [полезна](/user-centric-performance-metrics/#questions) . {% endAside %}

Исторически сложилось так, что веб-разработчикам было сложно измерить, насколько быстро основной контент веб-страницы загружается и становится видимым для пользователей.

Старые метрики, такие как [load](https://developer.mozilla.org/en-US/docs/Web/Events/load) или [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) , не подходят, потому что они не обязательно соответствуют тому, что пользователь видит на своем экране. А более новые, ориентированные на пользователя показатели производительности, такие как [First Contentful Paint (FCP),](/fcp/) отражают только самое начало процесса загрузки. Если на странице отображается заставка или отображается индикатор загрузки, этот момент не очень важен для пользователя.

Раньше мы рекомендовали такие показатели производительности, как [First Meaningful Paint (FMP)](/first-meaningful-paint/) и [Speed Index (SI)](/speed-index/) (оба доступны в Lighthouse), чтобы помочь уловить больше впечатлений от загрузки после начальной отрисовки, но эти показатели сложны, их трудно объяснить. , и часто ошибаются - это означает, что они все еще не определяют, когда загружено основное содержимое страницы.

Иногда лучше проще. Основываясь на обсуждениях в [рабочей группе W3C Web Performance](https://www.w3.org/webperf/) и исследованиях, проведенных в Google, мы обнаружили, что более точный способ измерить, когда загружается основное содержимое страницы, - это посмотреть, когда был отрисован самый большой элемент.

## Что такое LCP?

Метрика «Самая большая наполненная краска» (LCP) сообщает время рендеринга самого большого [изображения или текстового блока,](#what-elements-are-considered) видимого в области просмотра, относительно того, когда страница [впервые начала загружаться](https://w3c.github.io/hr-time/#timeorigin-attribute) .

<picture>
  <source srcset="{{ " image imgix media="(min-width: 640px)" width="400" height="100">{% Img src="image/eqprBhZUGfb8WYnumQ9ljAxRrA72/8ZW8LQsagLih1ZZoOmMR.svg", alt="Good LCP values are 2.5 seconds, poor values are greater than 4.0 seconds and anything in between needs improvement", width="400", height="300", class="w-screenshot w-screenshot--filled width-full" %}</source></picture>

### Что такое хороший показатель LCP?

Чтобы обеспечить удобство работы пользователей, сайты должны стремиться к тому, чтобы максимальная продолжительность рисования контента составляла **2,5 секунды** или меньше. Чтобы убедиться, что вы достигли этой цели для большинства пользователей, хорошим порогом для измерения является **75-й процентиль** загрузки страниц, сегментированный по мобильным и настольным устройствам.

{% Aside %} Чтобы узнать больше об исследованиях и методологии, лежащей в основе этой рекомендации, см. [Определение пороговых значений показателей Core Web Vitals](/defining-core-web-vitals-thresholds/) {% endAside %}

### Какие элементы считаются?

Как в настоящее время указано в [API самой большой Contentful Paint](https://wicg.github.io/largest-contentful-paint/) , для самой большой Contentful Paint рассматриваются следующие типы элементов:

- `<img>` элементы
- `<image>` внутри элемента `<svg>`
- `<video>` (используется изображение плаката)
- Элемент с фоновым изображением, загруженным с помощью функции [`url()`](https://developer.mozilla.org/en-US/docs/Web/CSS/url()) (в отличие от [градиента CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients) )
- [Элементы уровня блока,](https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements) содержащие текстовые узлы или другие дочерние текстовые элементы встроенного уровня.

Обратите внимание, что ограничение элементов этим ограниченным набором было намеренным, чтобы упростить задачу вначале. Дополнительные элементы (например, `<svg>` , `<video>` ) могут быть добавлены в будущем по мере проведения дополнительных исследований.

### Как определяется размер элемента?

Размер элемента, о котором сообщается для самой большой Contentful Paint, обычно равен размеру, который виден пользователю в области просмотра. Если элемент выходит за пределы области просмотра, или если какой-либо элемент обрезан или имеет невидимое [переполнение](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow) , эти части не учитываются в размере элемента.

Для элементов изображения, размер которых был изменен по сравнению с их [внутренним размером](https://developer.mozilla.org/en-US/docs/Glossary/Intrinsic_Size) , размер, о котором сообщается, является либо видимым размером, либо внутренним размером, в зависимости от того, что меньше. Например, изображения, уменьшенные до размера, намного меньшего, чем их собственный размер, будут сообщать только размер, в котором они отображаются, тогда как изображения, которые растянуты или расширены до большего размера, будут сообщать только свои внутренние размеры.

Для текстовых элементов учитывается только размер их текстовых узлов (наименьший прямоугольник, охватывающий все текстовые узлы).

Для всех элементов не учитываются поля, отступы или границы, применяемые с помощью CSS.

{% Aside %} Определение того, какие текстовые узлы каким элементам принадлежат, иногда бывает непросто, особенно для элементов, чьи дочерние элементы включают встроенные элементы и узлы простого текста, а также элементы уровня блока. Ключевым моментом является то, что каждый текстовый узел принадлежит (и только ему) своему ближайшему элементу-предку на уровне блока. В [терминах спецификации](https://wicg.github.io/element-timing/#set-of-owned-text-nodes) : каждый текстовый узел принадлежит элементу, который генерирует [содержащий](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block) его блок. {% endAside %}

### Когда сообщается о самой большой содержательной краске?

Веб-страницы часто загружаются поэтапно, и в результате может измениться самый большой элемент на странице.

Чтобы справиться с этой возможностью изменения, браузер отправляет [`PerformanceEntry`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry) типа `largest-contentful-paint` идентифицирующий самый большой контентный элемент, как только браузер отрисовывает первый кадр. Но затем, после рендеринга последующих кадров, он будет отправлять другой [`PerformanceEntry`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry) каждый раз, когда изменяется самый большой содержательный элемент.

Например, на странице с текстом и изображением главного героя браузер может сначала просто отобразить текст - в этот момент браузер отправит запись `largest-contentful-paint` , `element` которой, скорее всего, будет ссылаться на `<p>` или `<h1>` . Позже, как только изображение героя завершит загрузку, будет отправлена `largest-contentful-paint` `element` будет ссылаться на `<img>` .

Важно отметить, что элемент может считаться самым большим элементом содержимого только после того, как он отрисован и станет видимым для пользователя. Еще не загруженные изображения не считаются "обработанными". Также текстовые узлы не используют веб-шрифты в период [блокировки шрифтов](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display#The_font_display_timeline) . В таких случаях о меньшем элементе может быть сообщено как о самом большом содержательном элементе, но как только более крупный элемент завершит рендеринг, он будет сообщен через другой объект `PerformanceEntry`

В дополнение к поздней загрузке изображений и шрифтов страница может добавлять новые элементы в DOM по мере того, как новое содержимое становится доступным. Если какой-либо из этих новых элементов больше, чем предыдущий самый большой содержательный элемент, также будет сообщено о `PerformanceEntry`

Если элемент, который в настоящее время является самым большим элементом содержимого, удаляется из области просмотра (или даже удаляется из DOM), он останется самым большим элементом содержимого, если не будет визуализирован более крупный элемент.

{% Aside %} До Chrome 88 удаленные элементы не считались элементами с наибольшим содержанием содержимого, и удаление текущего кандидата приводило к отправке `largest-contentful-paint` Однако из-за популярных шаблонов пользовательского интерфейса, таких как карусели изображений, которые часто удаляли элементы DOM, метрика была обновлена, чтобы более точно отражать то, что испытывают пользователи. Смотрите [ИЗМЕНЕНИЯ](https://chromium.googlesource.com/chromium/src/+/master/docs/speed/metrics_changelog/2020_11_lcp.md) для более подробной информации. {% endAside %}

Браузер перестанет сообщать о новых записях, как только пользователь взаимодействует со страницей (с помощью касания, прокрутки или нажатия клавиш), поскольку взаимодействие с пользователем часто меняет то, что видно пользователю (что особенно верно при прокрутке).

В целях анализа вы должны сообщать в службу аналитики `PerformanceEntry`

{% Aside 'caution' %} Так как пользователи могут открывать страницы на фоновой вкладке, возможно, что самая большая содержательная отрисовка не произойдет, пока пользователь не сфокусирует вкладку, что может произойти намного позже, чем когда они впервые загрузили ее. {% endAside %}

#### Время загрузки и время рендеринга

По соображениям безопасности метка времени рендеринга изображений не отображается для изображений из разных источников, у которых отсутствует заголовок [`Timing-Allow-Origin`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin) Вместо этого отображается только время их загрузки (поскольку оно уже доступно через многие другие веб-API).

В [приведенном ниже примере использования](#measure-lcp-in-javascript) показано, как обрабатывать элементы, время рендеринга которых недоступно. Но, по возможности, всегда рекомендуется устанавливать [`Timing-Allow-Origin`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin) , чтобы ваши показатели были более точными.

### Как обрабатываются изменения макета и размера элемента?

Чтобы снизить накладные расходы производительности на вычисление и отправку новых записей производительности, изменения размера или положения элемента не создают новых кандидатов LCP. Учитывается только начальный размер и положение элемента в области просмотра.

Это означает, что изображения, которые изначально визуализируются за пределами экрана, а затем переходят на экран, могут не передаваться. Это также означает, что элементы, изначально визуализированные в области просмотра, которые затем выталкиваются из поля зрения, по-прежнему сообщают о своем первоначальном размере в области просмотра.

### Примеры

Вот несколько примеров того, когда самая большая отрисовка контента происходит на нескольких популярных веб-сайтах:

{% Img src="image/admin/bsBm8poY1uQbq7mNvVJm.png", alt="Largest Contentful Paint timeline from cnn.com", width="800", height="311" %}

{% Img src="image/admin/xAvLL1u2KFRaqoZZiI71.png", alt="Largest Contentful Paint timeline from techcrunch.com", width="800", height="311" %}

На обеих шкалах времени, указанных выше, самый большой элемент изменяется по мере загрузки содержимого. В первом примере новый контент добавляется в DOM, и это меняет самый большой элемент. Во втором примере макет изменяется, и содержимое, которое ранее было самым большим, удаляется из области просмотра.

Хотя часто бывает, что содержимое с поздней загрузкой больше содержимого, уже находящегося на странице, это не всегда так. Следующие два примера показывают, что самая большая отрисовка содержимого происходит до полной загрузки страницы.

{% Img src="image/admin/uJAGswhXK3bE6Vs4I5bP.png", alt="Largest Contentful Paint timeline from instagram.com", width="800", height="311" %}

{% Img src="image/admin/e0O2woQjZJ92aYlPOJzT.png", alt="Largest Contentful Paint timeline from google.com", width="800", height="311" %}

В первом примере логотип Instagram загружается относительно рано и остается самым крупным элементом, даже когда другой контент отображается постепенно. В примере страницы результатов поиска Google самый большой элемент - это абзац текста, который отображается до того, как любое из изображений или логотипа завершит загрузку. Поскольку все отдельные изображения меньше этого абзаца, он остается самым большим элементом в процессе загрузки.

{% Aside %} В первом кадре временной шкалы Instagram вы можете заметить, что вокруг логотипа камеры нет зеленой рамки. Это потому , что это `<svg>` элемент, и `<svg>` элементы в настоящее время не считаются кандидаты LCP. Первый кандидат LCP - это текст во втором кадре. {% endAside %}

## Как измерить LCP

LCP можно измерить [в лаборатории](/user-centric-performance-metrics/#in-the-lab) или [в полевых условиях](/user-centric-performance-metrics/#in-the-field) , и это доступно с помощью следующих инструментов:

### Полевые инструменты

- [Отчет об удобстве использования Chrome](https://developers.google.com/web/tools/chrome-user-experience-report)
- [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)
- [Search Console (отчет Core Web Vitals)](https://support.google.com/webmasters/answer/9205520)
- [библиотека JavaScript `web-vitals`](https://github.com/GoogleChrome/web-vitals)

### Лабораторные инструменты

- [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/)
- [Маяк](https://developers.google.com/web/tools/lighthouse/)
- [WebPageTest](https://webpagetest.org/)

### Измерьте LCP в JavaScript

Чтобы измерить LCP в JavaScript, вы можете использовать самый [большой Contentful Paint API](https://wicg.github.io/largest-contentful-paint/) . В следующем примере показано, как создать [`PerformanceObserver`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver) который прослушивает записи `largest-contentful-paint` и записывает их в консоль.

```js
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.log('LCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'largest-contentful-paint', buffered: true});
```

{% Aside 'warning' %}

Этот код показывает, как записывать `largest-contentful-paint` , но измерение LCP в JavaScript сложнее. Подробнее см. Ниже:

{% endAside %}

В приведенном выше примере каждая зарегистрированная `largest-contentful-paint` представляет текущего кандидата LCP. Как правило, `startTime` последней отправленной записи является значением LCP, однако это не всегда так. Не все записи с `largest-contentful-paint` подходят для измерения LCP.

В следующем разделе перечислены различия между тем, что сообщает API, и тем, как рассчитывается метрика.

#### Различия между метрикой и API

- API будет отправлять записи с `largest-contentful-paint` для страниц, загруженных на фоновой вкладке, но эти страницы следует игнорировать при вычислении LCP.
- API будет продолжать отправлять записи с `largest-contentful-paint` после того, как страница была фоновой, но эти записи следует игнорировать при вычислении LCP (элементы могут учитываться только в том случае, если страница все время находилась на переднем плане).
- API не сообщает о `largest-contentful-paint` когда страница восстанавливается из [кэша назад / вперед](/bfcache/#impact-on-core-web-vitals) , но в этих случаях следует измерять LCP, поскольку пользователи воспринимают их как отдельные посещения страницы.
- API не учитывает элементы внутри фреймов, но для правильного измерения LCP вы должны их учитывать. Подкадры могут использовать API, чтобы сообщать о своих `largest-contentful-paint` в родительский кадр для агрегирования.

Вместо того, чтобы запоминать все эти тонкие различия, разработчики могут использовать [библиотеку JavaScript `web-vitals`](https://github.com/GoogleChrome/web-vitals) для измерения LCP, которая обрабатывает эти различия за вас (где это возможно):

```js
import {getLCP} from 'web-vitals';

// Measure and log LCP as soon as it's available.
getLCP(console.log);
```

Вы можете обратиться к [исходному коду `getLCP()`](https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts) для получения полного примера того, как измерить LCP в JavaScript.

{% Aside %} В некоторых случаях (например, в iframe с перекрестным происхождением) невозможно измерить LCP в JavaScript. См. Подробности в разделе [ограничений](https://github.com/GoogleChrome/web-vitals#limitations) библиотеки `web-vitals` {% endAside %}

### Что, если самый большой элемент не самый важный?

В некоторых случаях самый важный элемент (или элементы) на странице не совпадает с самым большим элементом, и разработчики могут быть более заинтересованы в измерении времени рендеринга этих других элементов. Это возможно с помощью [Element Timing API](https://wicg.github.io/element-timing/) , как описано в статье о [пользовательских показателях](/custom-metrics/#element-timing-api) .

## Как улучшить LCP

На LCP в первую очередь влияют четыре фактора:

- Медленное время ответа сервера
- JavaScript и CSS с блокировкой рендеринга
- Время загрузки ресурса
- Клиентский рендеринг

Подробные сведения о том, как улучшить LCP, см. В разделе [Оптимизация LCP](/optimize-lcp/) . Дополнительные рекомендации по отдельным методам повышения производительности, которые также могут улучшить LCP, см.

- [Применяйте мгновенную загрузку с шаблоном PRPL](/apply-instant-loading-with-prpl)
- [Оптимизация критического пути отрисовки](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/)
- [Оптимизируйте свой CSS](/fast#optimize-your-css)
- [Оптимизируйте свои изображения](/fast#optimize-your-images)
- [Оптимизировать веб-шрифты](/fast#optimize-web-fonts)
- [Оптимизируйте свой JavaScript](/fast#optimize-your-javascript) (для сайтов, отображаемых клиентом)

## Дополнительные ресурсы

- [Уроки, извлеченные Анни Салливан](https://anniesullie.com/) [из мониторинга производительности в Chrome](https://youtu.be/ctavZT87syI) на [performance.now ()](https://perfnow.nl/) (2019)

{% include 'content/metrics/metrics-changelog.njk' %}
